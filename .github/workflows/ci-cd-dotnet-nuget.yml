name: Teq Bench - CI/CD - Create a NuGet package and (optionally) deploy to the organization's package registry on GitHub.

on: 
  workflow_call:
    inputs:
      repository:
        description: The respository to create a release for and, optionally, create a NuGet package for.
        type: string
        required: true

      resource_url:
        type: string
        description: 'The URL of the issue/PR to get or update'
        required: true
        default: 'https://github.com/teq-bench/sandbox-auto-versioning/issues/17'

      project_number:
        description: The project number the supplied resource URL is associated with to update.
        type: string
        required: true
        default: "2"

      create-nuget-package:
        description: Create and upload a NuGet package to the Org's package repository on GitHub. Defaults to false.
        type: boolean
        required: true
        default: false
        
env:
  ORGANIZATION: 'teq-bench'
  REPOSITORY: ${{ inputs.repository }}
  PROJECT_URL: https://github.com/orgs/teq-bench/projects/${{ inputs.project_number }}
  RESOURCE_URL: ${{ inputs.resource_url }}
  CREATE_NUGET_PACKAGE: ${{ inputs.create-nuget-package }}
  VERSION_FILE: "version.json"
  CI_TAG_MESSAGE: "Teq Bench - GitHub Build Artifacts"
  GIT_CONFIG_AUTHOR: "Teq Bench"
  GIT_CONFIG_EMAIL: "teq-bench@noreply.github.com"
  
jobs:
  init:
    runs-on: ubuntu-latest
    steps:
      - name: Wait for prior instances of the workflow to finish
        uses: softprops/turnstyle@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  merge_check:
    needs: init
    runs-on: ubuntu-latest
    steps:
      - name: Is pull request closed and merged?
        if: github.event.pull_request.merged != true
        run: |
          echo "Pull request has been closed, but not merged."
          echo "This CI/CD workflow requires the pull request be merged in order to proceed."
          echo "Exiting workflow."
          exit 1

  variables:
    needs: merge_check
    runs-on: ubuntu-latest
    steps:
      - name: Get Mergable Field Value
        id: get_mergable_field_value
        uses: teq-bench/project-fields@v2.1
        with:
          operation: get
          fields: Mergable
          github_token: ${{ secrets.DEVOPS_PROJECT_READER_TOKEN }}
          project_url: ${{ env.PROJECT_URL }}
          resource_url: ${{ env.RESOURCE_URL }}
          
      - name: Get Release Type Field Value
        id: get_release_type_field_value
        uses: teq-bench/project-fields@v2.1
        with:
          operation: get
          fields: Release Type
          github_token: ${{ secrets.DEVOPS_PROJECT_READER_TOKEN }}
          project_url: ${{ env.PROJECT_URL }}
          resource_url: ${{ env.RESOURCE_URL }}
          
      - name: Assign Field Values To Variables
        id: assign_field_values_to_variables
        run: |
          echo "mergable_value=${{ steps.get_mergable_field_value.outputs.values }}" >> $GITHUB_OUTPUT
          echo "release_type_value=${{ steps.get_release_type_field_value.outputs.values }}" >> $GITHUB_OUTPUT
          
    outputs:
      MERGABLE: ${{ steps.assign_mergable_field_value.outputs.mergable_value }}
      RELEASE_TYPE: ${{ steps.assign_release_type_field_value.outputs.release_type_value }}
          
  create-release:
    runs-on: ubuntu-latest
    needs: variables
    # Although could just check fot see if RELEASE_TYPE is an empty string, be explicit with the valid values it can be in order to proceed.
    if: ${{ contains(needs.variables.outputs.RELEASE_TYPE, 'Major') || contains(needs.variables.outputs.RELEASE_TYPE, 'Minor') || contains(needs.variables.outputs.RELEASE_TYPE, 'Patch') }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.REPOSITORY }}
          ref: main
          token: ${{ secrets.DEVOPS_ACTIONS_PAT_TOKEN }}

      - name: Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: trading-toolbox/version-number-components-action
          ref: v10
          path: ./.github/actions/version-number-components-action
          token: ${{ secrets.DEVOPS_ACTIONS_PAT_TOKEN }}
       
      - name: Read Version File
        id: read-version-file
        # use 'jq' to read json data from the version.json file
        # -c means to compact the output stream data instead of the default 'pretty-print' behavior
        # . is the identity operator and it copies the input of the jq processor to the output stream
        run: |
          echo "version-json=$(jq -c . ${{ env.VERSION_FILE }})" >> $GITHUB_OUTPUT

      - name: Get Current Version Number Components
        id: get-version-number-components
        uses: ./.github/actions/version-number-components-action
        with:
          release-type: ${{ needs.variables.outputs.RELEASE_TYPE }}
          version-json: ${{ steps.read-version-file.outputs.version-json }}
          
      - name: Update Version File
        run: |
          echo "`jq '(..|.major?) = ${{ steps.get-version-number-components.outputs.major }} | 
          (..|.minor?) = ${{ steps.get-version-number-components.outputs.minor }} | 
          (..|.patch?) = ${{ steps.get-version-number-components.outputs.patch }} | 
          (..|.build?) = ${{ steps.get-version-number-components.outputs.build }} | 
          (..|.revision?) = ${{ steps.get-version-number-components.outputs.revision }} 
          | (..|.suffix?) = \"${{ steps.get-version-number-components.outputs.suffix }}\"' ${{ env.VERSION_FILE }}`" > ${{ env.VERSION_FILE }}
      
      - name: Git Config
        run: |
          git config --global user.name '${{ env.GIT_CONFIG_AUTHOR }}'
          git config --global user.email '${{ env.GIT_CONFIG_EMAIL }}'    
          
      - name: Commit Changes To Version File
        run: |
          git add ${{ env.VERSION_FILE }}
          git commit -m "Update to version ${{ steps.get-version-number-components.outputs.version }}"
          git push
          
      - name: Tag & Push
        run: |
          git tag -a ${{ steps.get-version-number-components.outputs.tag }} -m "Added tag ${{ steps.get-version-number-components.outputs.tag }}"
          git push origin ${{ steps.get-version-number-components.outputs.tag }}

      - name: Create Release & Generate Notes
        run: gh release create ${{ steps.get-version-number-components.outputs.tag }} --generate-notes --repo ${{ env.REPOSITORY }}
        env:
          GITHUB_TOKEN: ${{ secrets.DEVOPS_ACTIONS_PAT_TOKEN }}
    outputs:
      MAJOR: ${{ steps.get-version-number-components.outputs.major }}
      MINOR: ${{ steps.get-version-number-components.outputs.minor }}
      PATCH: ${{ steps.get-version-number-components.outputs.patch }}
      BUILD: ${{ steps.get-version-number-components.outputs.build }}
      REVISION: ${{ steps.get-version-number-components.outputs.revision }}
      TAG: ${{ steps.get-version-number-components.outputs.tag }}

  create-package:
    runs-on: ubuntu-latest
    needs: create-release
    env:
      BUILD_CONFIG: 'Release'
      # This environment variable is implicitly required by the Setup .NET step
      NUGET_AUTH_TOKEN: ${{secrets.DEVOPS_PACKAGE_PUBLISHER_TOKEN}}
    if: ${{ env.CREATE_NUGET_PACKAGE == true }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.REPOSITORY }}
          ref: ${{ needs.create-release.outputs.TAG }}
          token: ${{ secrets.DEVOPS_ACTIONS_PAT_TOKEN }}
              
      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: 7.0.X
          source-url: https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json

      - name: Restore Dependencies
        run: dotnet restore

      - name: Build Solution
        # The dotnet command would not run here using multiline; once put all on single line, ran successfully.
        run: dotnet build -c:${{ env.BUILD_CONFIG }} -p:major=${{ needs.create-release.outputs.MAJOR }} -p:minor=${{ needs.create-release.outputs.MINOR }} -p:patch=${{ needs.create-release.outputs.PATCH }} -p:build=${{ needs.create-release.outputs.BUILD }} -p:revision=${{ needs.create-release.outputs.REVISION }} --no-restore

      - name: Create Package
        # The dotnet command would not run here using multiline; once put all on single line, ran successfully.
        run: dotnet pack -c:${{ env.BUILD_CONFIG }} -p:major=${{ needs.create-release.outputs.MAJOR }} -p:minor=${{ needs.create-release.outputs.MINOR }} -p:patch=${{ needs.create-release.outputs.PATCH }} -p:build=${{ needs.create-release.outputs.BUILD }} -p:revision=${{ needs.create-release.outputs.REVISION }} --no-build
      
      - name: Publish Package
        # The token, DEVOPS_PACKAGE_PUBLISHER_TOKEN, belongs to the devops-teqbench-com user and has repo/packages:write scope
        # however, publishing appears to only work when the owner of the supplied town is also assigned the 'owner' role
        # within the GitHub organzation which own's the repo being packaged/published.
        run: dotnet nuget push bin/Release/*.nupkg --skip-duplicate --api-key ${{secrets.DEVOPS_PACKAGE_PUBLISHER_TOKEN}}
      
