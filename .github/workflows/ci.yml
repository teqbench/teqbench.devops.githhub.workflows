name: Common .NET Build and Test CI Workflow
# TeqBench - Common CI workflow to build and test a .NET repo.

on: 
  workflow_call:
    inputs:
      repository:
        description: "The respository to build and test."
        type: string
        default: ${{ github.repository }}

      repository_owner:
        description: "The respository's owner, i.e. teqbench."
        type: string
        default: ${{ github.repository_owner }}

      repository_name:
        description: "The respository's name without owner, i.e. ci-cd-workflows."
        type: string
        default: ${{ github.event.repository.name }}

      # resource_url:
      #   type: string
      #   description: "The URL of the issue/PR to get or update"
      #   default: ${{ github.event.issue.html_url || github.event.pull_request.html_url }}

      # event_number:
      #   description: "The issue/pr number the supplied resource URL is associated with to validate."
      #   type: string
      #   required: true
        
      # project_number:
      #   description: "The project number the supplied resource URL is associated with to update."
      #   type: string
      #   required: true

      project_source_folder:
        description: "The folder the project to be packaged as NuGet package is located."
        type: string
        default: './src'
        
      badges_folder:
        description: "The folder for the repo's badges."
        type: string
        default: './.badges'
      
      coverage_folder:
        description: "The folder for the repo's coverage data and reports."
        type: string
        default: './.coverage'


env:
  BUILD_CONFIG_DOTNET_VERSION: '8.0.X'
  BUILD_CONFIG_NAME: 'Release'
  BUILD_CONFIG_RELEASE_TYPE: 'BUILD'
  BUILD_CONFIG_REPOSITORY: ${{ inputs.repository }}
  BUILD_CONFIG_BRANCH: 'main'
  BUILD_CONFIG_REPOSITORY_OWNER: ${{ inputs.repository_owner }}
  BUILD_CONFIG_REPOSITORY_NAME: ${{ inputs.repository_name }}
  FOLDER_PATH_SOURCE: ${{ inputs.project_source_folder }}    
  FOLDER_PATH_BADGES: '${{ inputs.badges_folder }}'
  FOLDER_PATH_COVERAGE: '${{ inputs.coverage_folder }}'
  FILE_PATH_VERSION: '${{ inputs.project_source_folder }}/version.json'    
  FILE_PATH_BADGE_BUILD_STATUS: '${{ inputs.badges_folder }}/build-status.svg'
  FILE_PATH_BADGE_BUILD_NUMBER: '${{ inputs.badges_folder }}/build-number.svg'
  FILE_PATH_BADGE_COVERAGE: '${{ inputs.badges_folder }}/code-coverage.svg'
  FILE_PATH_BADGE_RELEASE_DATE: '${{ inputs.badges_folder }}/release-date.svg'
  FILE_PATH_BADGE_RELEASE_TAG: '${{ inputs.badges_folder }}/release-tag.svg'
  FILE_PATH_BADGE_DEPLOY_DATE: '${{ inputs.badges_folder }}/deploy-date.svg'
  FILE_PATH_BADGE_DEPLOY_VERSION: '${{ inputs.badges_folder }}/deploy-version.svg'
  COVERAGE_UPPER_BOUNDARY: 75
  COVERAGE_LOWER_BOUNDARY: 60

# The `concurrency` key ensures that only a single workflow in the same concurrency group will run at the same time. 
# For more information, see "[AUTOTITLE](/actions/using-jobs/using-concurrency)."
# `concurrency.group` generates a concurrency group name from the workflow name and repository name. 
# The `||` operator is used to define fallback values.
concurrency:
    group: '${{ github.workflow }} @ ${{ github.repository || github.head_ref || github.ref }}'

jobs:
  # merge_check:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Is pull request closed and merged?
  #       if: github.event.pull_request.merged != true
  #       run: |
  #         echo "Pull request has been closed, but not merged."
  #         echo "This CI/CD workflow requires the pull request be merged in order to proceed."
  #         echo "Exiting workflow."
  #         exit 1
    
  build-and-test:
    # needs: merge_check
    runs-on: ubuntu-latest
    # needs: variables

    permissions:
      contents: write
    
    env:
      # This environment variable is implicitly required by the Setup .NET step
      NUGET_AUTH_TOKEN: ${{secrets.DEVOPS_PACKAGE_PUBLISHER_TOKEN}}
    steps:
    - name: Git Config
      run: |
        git config --global user.name '${{ vars.ORG_DEVOPS_GIT_CONFIG_AUTHOR }}'
        git config --global user.email '${{ vars.ORG_DEVOPS_GIT_CONFIG_EMAIL }}'    

    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        repository: ${{ env.BUILD_CONFIG_REPOSITORY }}
        ref: ${{ env.BUILD_CONFIG_BRANCH }}
        submodules: recursive
        token: ${{ secrets.DEVOPS_ACTIONS_PAT_TOKEN }}

    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: ${{ env.BUILD_CONFIG_DOTNET_VERSION }}
        source-url: https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json

    - name: Restore .NET Project Dependencies
      run: dotnet restore

    - name: Get Current Version JSON From Version File
      id: get-version-json
      # use 'jq' to read json data from the version.json file
      # -c means to compact the output stream data instead of the default 'pretty-print' behavior
      # . is the identity operator and it copies the input of the jq processor to the output stream
      run: |
        echo "version-json=$(jq -c . ${{ env.FILE_PATH_VERSION }})" >> $GITHUB_OUTPUT

    # Increment the build number BEFORE building the solution so have the updated version number components to pass as parameters.
    - name: Increment Build Number
      id: increment-build-number
      uses: teqbench/teqbench.devops.githhub.actions.version-updater@v14
      with:
        # By specifying a release type of "BUILD", only the build number will be incremented.
        release-type: ${{ env.BUILD_CONFIG_RELEASE_TYPE }}
        version-json: ${{ steps.get-version-json.outputs.version-json }}

    - name: Build Solution
      id: build-solution
      # The dotnet command would not run here using multiline; once put all on single line, ran successfully.
      # This will build ALL projects in the solution.
      run: dotnet build -c:${{ env.BUILD_CONFIG_NAME }} -p:major=${{ steps.increment-build-number.outputs.major }} -p:minor=${{ steps.increment-build-number.outputs.minor }} -p:patch=${{ steps.increment-build-number.outputs.patch }} -p:build=${{ steps.increment-build-number.outputs.build }} -p:revision=${{ steps.increment-build-number.outputs.revision }} --no-restore

    # Only run unit tests if all prior steps, including the Build Solution step, were successful.
    - name: Run Unit Tests
      id: run-unit-tests
      if: ${{ success() }}
      run: dotnet test --no-restore

    # Always update the version file with new build number, even if build fails, and if the increment build number step was successful.
    - name: Update Version File With New Build Number
      if: ${{ always() && steps.increment-build-number.outcome == 'success' }}
      id: update-version-file
      run: |
        echo "`jq '(..|.major?) = ${{ steps.increment-build-number.outputs.major }} | 
        (..|.minor?) = ${{ steps.increment-build-number.outputs.minor }} | 
        (..|.patch?) = ${{ steps.increment-build-number.outputs.patch }} | 
        (..|.build?) = ${{ steps.increment-build-number.outputs.build }} | 
        (..|.revision?) = ${{ steps.increment-build-number.outputs.revision }} 
        | (..|.suffix?) = \"${{ steps.increment-build-number.outputs.suffix }}\"' ${{ env.FILE_PATH_VERSION }}`" > ${{ env.FILE_PATH_VERSION }}

    # Always commit the version file with new build number, even if build fails, and if the update version file step was successful.
    - name: Commit Changes To Version File
      id: commit-version-file
      if: ${{ always() && steps.update-version-file.outcome == 'success' }}
      run: |
        git add ${{ env.FILE_PATH_VERSION }}
        git commit -m "Update to version ${{ steps.increment-build-number.outputs.version }}"

    - name: Create Badges Directory If Does Not Exist
      if: ${{ always() }}
      run: mkdir -p ${{ env.FOLDER_PATH_BADGES }}
  
    - name: Update Build Status Badge
      id: update-build-status-badge
      if: ${{ always() }}
      uses: teqbench/teqbench.devops.githhub.actions.badge-maker@v1.0.2
      with:
        badge-type: ${{ contains(steps.build-solution.outcome,'success') && 'PASSING' || 'FAILING' }}
        label: 'build'
  
    # If new build status badge file is the same as one being overwritten, git will NOT detect a change in the file as both are same size.
    - name: Save Build Status Badge File
      id: save-build-status-badge-file
      if: ${{ always() && steps.update-build-status-badge.outcome == 'success' }}
      run: echo '${{ steps.update-build-status-badge.outputs.svg }}' > '${{ env.FILE_PATH_BADGE_BUILD_STATUS }}'
    
    - name: Update Build Number Badge
      id: update-build-number-badge
      if: ${{ always() }}
      uses: teqbench/teqbench.devops.githhub.actions.badge-maker@v1.0.2
      with:
        badge-type: 'INFORMATION'
        label: 'build #'
        message: ${{ (contains(steps.increment-build-number.outcome,'success') && contains(steps.commit-version-file.outcome,'success')) && steps.increment-build-number.outputs.build || 'N/A' }}

    - name: Save Build Number Badge File
      id: save-build-number-badge-file
      if: ${{ always() && steps.update-build-number-badge.outcome == 'success' }}
      run: echo '${{ steps.update-build-number-badge.outputs.svg }}' > '${{ env.FILE_PATH_BADGE_BUILD_NUMBER }}'

    # Read coverage xml from file
    - name: Read Coverage File
      id: read-coverage-file
      if: ${{ steps.run-unit-tests.outcome == 'success' }}
      run: |
        echo xml=$(<${{ env.FOLDER_PATH_COVERAGE }}/coverage.cobertura.xml) >> $GITHUB_OUTPUT

    # pass coverage xml to action to get coverage %
    - name: Get Coverage Value
      id: get-coverage-value
      if: ${{ steps.run-unit-tests.outcome == 'success' && steps.read-coverage-file.outcome == 'success' }}
      uses: teqbench/teqbench.devops.githhub.actions.coverage-reader@v2.0.1
      with:
        coverage-xml: '${{ steps.read-coverage-file.outputs.xml }}'

    # coverage >=75.0 success
    # coverage >= 60 and coverage < 75.0 warning
    # coverage < 60 failing
    - name: Determine Coverage Badge Type
      id: determine-coverage-badge-type
      run: |
        echo "badge-type=${{ (contains(steps.get-coverage-value.outcome,'success') && (steps.get-coverage-value.outputs.coverage >= env.COVERAGE_UPPER_BOUNDARY) && 'SUCCESS' || 'FAILURE' }}" >> $GITHUB_OUTPUT

    - name: Update Coverage Badge
      id: update-coverage-badge
      if: ${{ always() }}
      uses: teqbench/teqbench.devops.githhub.actions.badge-maker@v1.0.2
      with:
        badge-type: ${{ contains(steps.determine-coverage-badge-type.outcome,'success') && steps.determine-coverage-badge-type.outputs.badge-type || 'FAILURE' }}
        label: 'coverage'
        message: ${{ format('{0}', contains(steps.get-coverage-value.outcome,'success') && steps.get-coverage-value.outputs.coverage-foratted || '0%') }}

    - name: Save Coverage Badge File
      id: save-coverage-badge-file
      if: ${{ always() && steps.update-coverage-badge.outcome == 'success' }}
      run: echo '${{ steps.update-coverage-badge.outputs.svg }}' > '${{ env.FILE_PATH_BADGE_COVERAGE }}'
          
    # update coverage badge
    # save coverage badge

    # # If new coverage badge file is the same as one being overwritten, git will NOT detect a change in the file as both are same size.
    # - name: Update Code Coverage Badge
    #   id: update-code-coverage-badge
    #   uses: teqbench/teqbench.devops.githhub.actions.badge-maker@v1.0.2
    #   with:
    #     badge-type: 'WARNING'
    #     label: 'Coverage'
    #     message: '65%'

    # - name: Save Code Coverage Badge File
      # id: save-code-coverage-badge-file
      # run: echo '${{ steps.update-code-coverage-badge.outputs.svg }}' > '${{ env.FILE_PATH_BADGE_COVERAGE }}'

    # - name: Update Release Date Badge
    #   id: update-release-date-badge
    #   uses: teqbench/teqbench.devops.githhub.actions.badge-maker@v1.0.2
    #   with:
    #     badge-type: 'DATESTAMP'
    #     label: 'release date'
    #     datestamp-timezone: 'US/Mountain'
        
    # - name: Save Release Date Badge File
    #   id: save-release-date-badge-file
    #   run: echo '${{ steps.update-release-date-badge.outputs.svg }}' > '${{ env.FILE_PATH_BADGE_RELEASE_TAG }}'

    # - name: Update Release Tag Badge
    #   id: update-release-tag-badge
    #   uses: teqbench/teqbench.devops.githhub.actions.badge-maker@v1.0.2
    #   with:
    #     badge-type: 'INFORMATION'
    #     label: 'release tag'
    #     message: '${{ steps.increment-build-number.outputs.tag }}'
        
    # - name: Save Release Tag Badge File
    #   id: save-release-tag-badge-file
    #   run: echo '${{ steps.update-release-tag-badge.outputs.svg }}' > '${{ env.FILE_PATH_BADGE_RELEASE_DATE }}'      
        
    # Should ALWAYS have at least one change, and that is to the build number badge file.
    - name: Commit Badge Changes
      id: commit-badge-changes
      if: ${{ always() && steps.save-build-status-badge-file.outcome == 'success' && steps.save-build-number-badge-file.outcome == 'success' }}
      run: |
        git add ${{ env.FOLDER_PATH_BADGES }}
        git commit -m "Update repo badges."

    - name: Push All Build Commits
      # if: ${{ always() && steps.commit-version-file.outcome == 'success' && steps.commit-badge-changes.outcome == 'success' }}
      if: ${{ always() }}      
      run: |
        git push
  
